package demos;

import io.reactivex.rxjava3.core.Observable;
import org.junit.Before;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;

@SuppressWarnings("ResultOfMethodCallIgnored")
public class ErrorHandlers {
  Observable<Integer> numbers;
  Observable<String> letters;

  @Before
  public void setUp() {
    numbers = Observable.range(1, 10);
    letters = Observable.just("a", "b", "c", "d", "e", "f", "g");
  }

  @Test
  public void doOnErrorTest() {
    System.out.println("======================================================");
    System.out.println("= doOnError operator");
    System.out.println("======================================================");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by five!");
             }
           })
           .doOnError(e -> System.err.println("doOnError: " + e))
           .subscribe(System.out::println,
                      error -> System.err.println("subscribe.onError: " + error));
  }

  @Test
  public void onErrorCompleteTest() {
    // Swallows errors, any error triggers onComplete
    System.out.println("======================================================");
    System.out.println("= onErrorComplete operator");
    System.out.println("======================================================");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by five!");
             }
           })
           .doOnError(e -> System.err.println("*** secret error message ***"))
           .onErrorComplete()
           .subscribe(System.out::println,
                      e -> System.err.println("Should never reach here"),
                      () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorResumeNextTest() {
    System.out.println("======================================================");
    System.out.println("= onErrorResumeNext operator");
    System.out.println("======================================================");
    numbers
        .map(i -> {
          if (i % 5 == 0) {
            throw new Exception("Divisible by five!");
          }
          return i;
        })
        // If there's an error, return an empty observable (but don't break)
        // .onErrorResumeNext((e) -> Observable.empty())
        // If there's an error, return a replacement observable
        .onErrorResumeNext((e) -> Observable.just(10, 11, 12, 13, 14))
        .subscribe(System.out::println,
                   e -> System.err.println("Should never reach here"),
                   () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorReturnTest() {
    // If something goes wrong, return this instead (generated by a Function)
    // ...and complete!
    System.out.println("===== onErrorReturnNext =====");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by five!");
             }
           })
           .onErrorReturn((e) -> -1)
           .subscribe(System.out::println,
                      e -> System.err.println("Should never reach here"),
                      () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorReturnItemTest() {
    // If something goes wrong, have this instead (static value)
    System.out.println("===== onErrorReturnItem =====");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by " + "five!");
             }
           })
           .onErrorReturnItem(-1)
           .subscribe(System.out::println,
                      e -> System.err.println("Should never reach here"),
                      () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorResumeNextAtomic() {
    System.out.println("======================================================");
    System.out.println("= onErrorResumeNext operator");
    System.out.println("======================================================");
    AtomicInteger index = new AtomicInteger(0);
    numbers
        .doOnNext((i) -> index.getAndIncrement())
        .map(i -> {
          if (i % 5 == 0) {
            throw new Exception("Divisible by five!");
          }
          return i;
        })
        .onErrorResumeNext((e) -> numbers.skip(index.get()))
        .subscribe(System.out::println,
                   e -> System.err.println("Should never reach here"),
                   () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorResumeNextActuallyResumes() {
    numbers.map(i -> {
             if (i % 5 == 0) {
               return Observable.error(new RuntimeException("Divisible by five!"));
             }
             return Observable.just(i);
           })
           .flatMap(o -> {
             return o.onErrorResumeNext(e -> Observable.empty());
           })
           .subscribe(System.out::println,
                      e -> System.err.println("Should never reach here"),
                      () -> System.out.println("We're done here."));

  }
}
